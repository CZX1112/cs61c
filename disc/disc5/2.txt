2. CALL
下面是 CALL 堆栈图，详细说明了机器如何构建和执行 C 程序：

2.1 存储程序的概念是什么？它能让我们做什么？

指令实际上只是数据，因此我们可以这样对待它们。 这使我们能够编写可以操作其他程序而无需修改物理硬件的程序！

2.2 汇编器必须对代码进行多少遍？ 为什么？

两种，一种是查找所有标签地址，另一种是转换所有指令，同时使用这些标签地址来解析任何前向引用。

2.3 描述汇编器输出的目标文件的六个主要部分（标头、文本、数据、重定位表、符号表、调试信息）。

• 标题：其他部分的尺寸和位置
• 文本：机器代码
• 数据：源文件中任何数据的二进制表示形式
• 重定位表：标识需要由链接器“处理”的代码行（跳转到外部标签（例如 lib 文件）、对静态数据的引用）
• 符号表：文件标签和可跨文件引用的数据列表
• 调试信息：调试器的附加信息

2.4 CALL 中的哪一步解决了相对寻址问题？ 绝对寻址？

汇编器、链接器