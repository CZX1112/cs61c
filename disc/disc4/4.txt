供您参考，这里有一些算术运算和处理内存的基本指令（注意：ARG1 是参数寄存器 1，
ARG2 是参数寄存器 2，DR 是目标寄存器）：

您可能还会看到某些指令末尾有一个“i”，例如 addi、slli 等。这意味着 ARG2 变成了
“立即数”或整数，而不是使用寄存器。 在其他一些指令中也有立即数，例如 sw 和 lw。
 注意：任何给定指令中立即数的大小取决于它是什么类型的指令（稍后会详细介绍！）。

4.1 假设我们在内存中有一个包含 int* arr = {1,2,3,4,5,6,0} 的数组。 让寄存器 s0 保存 arr 
中索引为 0 的元素的地址。 您可以假设整数是四字节的，并且我们的值是字对齐的。 
RISC-V 代码片段的作用是什么？ 假设所有指令都在同一上下文中一个接一个地运行。

(a) lw t0, 12(s0)——将寄存器t0中的值设置为arr[3]

(b) sw t0, 16(s0)——将寄存器t0中的值存入arr[4]中

(b) slli t1, t0, 2——t0左移两位，获取t0地址偏移量，存入t1寄存器中
       add t2, s0, t1——将偏移量与数组原地址相加，获取arr[t0]处的地址值，存入t2寄存器中
       lw t3, 0(t2)——获取arr[t0]值存入t3寄存器中
       addi t3, t3, 1——t3寄存器的值自增1
       sw t3, 0(t2)——将t3寄存器中的值存回t2地址处，即为arr[t0]
       ——总体功能为：将arr[t0]处的值自增1

(c) lw t0, 0(s0)
      xori t0, t0. 0xFFF
      addi t0, t0, 1
      ——将t0寄存器中的值设置为-1 * arr[0]