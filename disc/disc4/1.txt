1.1 在调用一个函数并让该函数返回后，t 寄存器可能在函数执行期间已更改，而 a 寄存器则不能。

错误的。 a0 和 a1 寄存器通常用于存储函数的返回值，因此函数可以在返回前将它们的值设置为其返回值。

1.2 让 a0 指向数组 x 的开始。 lw s0, 4(a0) 总是将 x[1] 加载到 s0 中。

错误的。 这仅适用于四字节宽的数据类型，如 int 或 float。 对于像 char 这样只有一个字节宽的数据类型，
4(a0) 将返回字符串中的第五个或第八个字符，具体取决于编译器是小端还是大端。

1.3 假设没有编译器或操作系统保护，可以让代码跳转到存储在 0(a0) 处的数据并从那里执行指令。

真的。 如果您的编译器/操作系统允许（出于安全原因，有些不允许），您的代码可能会跳转到并执行通过
数组传递给程序的指令。 相反，您的代码也可以将其自身视为普通数据（如果您想查看更多详细信息，
请搜索自修改代码）。

1.4 将字符“d”添加到整数数组的地址中，可以得到该数组索引 25 处的元素（假设数组足够大）。

真的。 RISC-V 中的整数、字符串和内存地址之间没有根本区别（它们都是比特包），因此可以以这种方式
操作数据。 （不过，我们不推荐这样做）。

1.5 调用 jalr 是 jal 的简写表达式，它跳转到指定的标签并且不在任何地方存储返回地址。

错误的。 j label 是 jal x0, label 的简写标签。 jalr用于返回第二个参数指定的内存地址

1.6 调用 j 标签与调用 jal 标签完全相同。

错误的。 与上一题一样，j label 是 jal x0, label 的简写标签。 jal label 是 jal ra, label 的简写标签。

