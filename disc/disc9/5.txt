5. 代码分析

给定以下代码块，假设我们有一台总内存为 1 MiB 的字节寻址计算机，请分析命中率。 
它还具有 16 KiB 直接映射缓存和 1 KiB 块。 假设您的缓存开始处于冷状态。

#define NUM_INTS 8192 // 2ˆ13
int A[NUM_INTS]; // A lives at 0x10000
int i, total = 0;
for (i = 0; i < NUM_INTS; i += 128) {
A[i] = i; // Line 1
}
for (i = 0; i < NUM_INTS; i += 128) {
total += A[i]; // Line 2
}

5.1 这台计算机上的内存地址由多少位组成？

我们取 log2(1 MiB) = log2(2^20) = 20。

5.2 T:I:O 分解是什么？

Offset = log2(1 KiB) = log2(2^10) = 10
Index = log2(16 KiB/1 KiB ) = log2(16) = 4
Tag = 20 − 4 − 10 = 6

5.3 计算标记为 Line 1 的行的缓存命中率：

整数访问间隔 4 * 128 = 512 字节，这意味着每个块有 2 次访问。 
每个块中的第一次访问是强制高速缓存未命中，但第二次访问是命中，
因为 A[i] 和 A[i+128] 位于同一高速缓存块中。 因此，我们最终的命中率为 50%。

5.4 计算标记为第 2 行的行的缓存命中率：

A 的大小为 8192 * 4 = 2^15 字节。 这恰好是我们缓存大小的两倍。 在第 1 行末尾，
我们的缓存中有 A 的后半部分，但第 2 行从 A 的前半部分开始。因此，我们无法重用
从第 1 行引入的任何缓存数据，必须从头开始 。 因此，我们的命中率与第 1 行相同，
因为我们访问内存的方式与第 1 行完全相同。我们不必考虑缓存命中总数，因为编译器很
可能会将其存储在寄存器中。因此，我们 最终命中率为50%。