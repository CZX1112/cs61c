1. 理解T/I/O
使用缓存时，我们必须能够分解所使用的内存地址，以了解它们在缓存中的位置。 共有三个字段：
标签 - 用于区分使用相同索引的不同块。 位数：（内存地址中的位数） - 索引位 - 偏移位
索引 - 这块内存将被放置在的集合。位数：log2（索引数）
偏移量 - 字节在块中的位置。 位数：log2（块大小）
鉴于这些定义，以下内容正确：
log2(内存大小) = 地址位宽 = # 标记位 + # 索引位 + # 偏移位
另一个需要记住的有用的等式是：缓存大小 = 块大小 * 块数

2.1 假设我们有一个容量为 32B、块大小为 8B 的直接映射字节寻址缓存。 在每个地址的 32 位中，我们使用哪些位来查找要使用的缓存索引？

我们可以根据缓存拥有的集合数量来确定所需的索引位数。 由于我们的缓存是直接映射的，所以集合的数量与块的数量相同，
因此我们只需要计算出我们的缓存有多少个块。 使用上面的等式，我们可以看到块数 = 缓存大小/块大小，
因此我们的缓存有 32/8 = 4 个块。 我们需要 log2(4) = 2 位来区分 4 个块，因此我们有 2 个索引位。

为了确定索引位的确切位置，我们需要计算我们拥有的偏移位和标记位的数量。 偏移位数仅取决于块大小，
因此由于我们的块大小为 8B，因此我们需要 log2(8) = 3 位来区分块中的 8 个字节，因此我们有 3 个偏移位。
我们的偏移位取 向上的最低有效位，索引位是下一个最高有效位的集合。 将最高有效位（MSB，左侧）表示为 31，
最低有效位（LSB，右侧）表示为 0，具有 3 个偏移位意味着我们的索引位从第 3 位开始，因此我们使用第 3 位
和第 4 位 作为索引位。

2.2 哪些位是我们的标签位？ 我们的offset呢？

偏移量（在本例中）是 3 个最低有效位，因此重用上一个问题中的约定，偏移量位是位 0、1 和 2。
我们的标签是剩余的高位位，因此我们的标签位是 位 5-31。
0——2：偏移量位，3——4：索引位，5——31：标签位。

2.3 将以下每个字节内存访问分类为高速缓存命中 (H)、高速缓存未命中 (M) 或带有替换的高速缓存未命中 (R)。 
提示：拉出缓存可以帮助您更清楚地看到替换内容。

0x00000004 Tag 0, Index 0, Offset 4: M, Compulsory
0x00000005 Tag 0, Index 0, Offset 5: H
0x00000068 Tag 3, Index 1, Offset 0: M, Compulsory
0x000000C8 Tag 6, Index 1, Offset 0: R, Compulsory
0x00000068 Tag 3, Index 1, Offset 0: R, Conflict
0x000000DD Tag 6, Index 3, Offset 5: M, Compulsory
0x00000045 Tag 2, Index 0, Offset 5: R, Compulsory
0x00000004 Tag 0, Index 0, Offset 4: R, Capacity
0x000000C8 Tag 6, Index 1, Offset 0: R, Capacity