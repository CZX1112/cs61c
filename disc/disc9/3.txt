3. 缓存关联性
在上一个问题中，我们有一个直接映射缓存，其中块映射到缓存中的特定一个插槽。 这有利于快速更换和查找块，但不利于空间效率！
这就是我们将关联性引入事物的地方。 我们将关联性定义为块可以映射到缓存中的槽数。 因此，全关联缓存具有最高的关联性，
这意味着每个块都可以到达缓存中的任何位置。
对于 N 路关联缓存，以下情况成立：
N ∗ # sets = # blocks

3.1 下面是一些涉及 2 路组关联缓存的实践。 这次我们有一个 8 位地址空间、8 个 B 块和 32 B 的缓存大小。
将以下每个访问分类为缓存命中 (H)、缓存未命中 (M) 或缓存未命中且替换 (R) 。 对于任何未命中，请列出未命中的类型。
假设我们有一个LRU替换策略（一般来说，情况并非如此）。

由于我们的缓存是 2 路组关联的，因此一组中有 2 个块。 我们的缓存尺寸与前面的示例相同，因此我们有 4 个块。
因此，我们的缓存中有 4/2 = 2 组。 我们需要 log2(2) = 1 位来区分 2 个集合，因此我们有 1 个索引位。 
我们的块大小与上一个问题相同，因此我们知道有 3 个偏移位，其余位是标记位。 同样，位 0、1 和 2 是我们的偏移位，
但现在唯一的索引位是位 3，位 4-31 是标记位。

0b0000 0100 Tag 0000, Index 0, Offset 100 - M, Compulsory
0b0000 0101 Tag 0000, Index 0, Offset 101 - H
0b0110 1000 Tag 0110, Index 1, Offset 000 - M, Compulsory
0b1100 1000 Tag 1100, Index 1, Offset 000 - M, Compulsory
0b0110 1000 Tag 0110, Index 1, Offset 000 - H
0b1101 1101 Tag 1101, Index 1, Offset 101 - R, Compulsory
0b0100 0101 Tag 0100, Index 0, Offset 101 - M, Compulsory
0b0000 0100 Tag 0000, Index 0, Offset 100 - H
0b1100 1000 Tag 1100, Index 1, Offset 000 - R, Capacity

3.2 我们上面的访问命中率是多少？

3/9 = 1/3 hit rate